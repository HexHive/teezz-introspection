
## What's this?

This project aims to provide a dynamic binary instrumentation based seed recorder *and* the corresponding recorder generator.
Given a function signature in C or C++,

```C
int cfunc(const struct foo *x, struct bar *y);
```

```C++
int cppfunc(const vector<struct foo>& x, vector<struct bar>& y);
```

we can generate a Frida hook that records the input, output, and return values for us.
The recorder generator uses type information from the corresponding header files to generate the recording logic.
Each item (e.g., parameter or return value) is recorded according to its type.
For example, in the C example above, the hook would interpret the memory pointed to by `x` as `struct foo*`.
Similarly, in the C++ example from above, the hook would interpret the memory pointed to by `x` as `vector<struct foo>`.

## Setup

Major parts of this project are written in *Python3*.
We recommend to install a py3 venv and `pip install -r requirements.txt`.

TODO: how to set up the libclang stuff properly?

## The Generator

There are two parts to the recorder generator, the interceptor, and the dumper.

### The Interceptor

The starting point for any recording is the interceptor.
We support intercepting multiple functions from one loadable object (i.e., a shared library).
The functions have to be specified via symbol or offset.
The interceptor code is generated based on handcrafted json files.

An example for the `keystore.hi6250.so` library written in C.
```
{
  "name" : "keystore.hi6250.so",
  "functions" : {
    "generate_key" : { "offset" : "0x498C" },
  }
}
```

An example for the `android.hardware.keymaster@3.0.so` library written in C++.
```
{
  "name" : "android.hardware.keymaster@3.0.so",
  "hal_functions" : {
    "generateKey" : { "symbol" : "_ZN7android8hardware9keymaster4V3_019BpHwKeymasterDevice11generateKeyERKNS0_8hidl_vecINS2_12KeyParameterEEENSt3__18functionIFvNS2_9ErrorCodeERKNS4_IhEERKNS2_18KeyCharacteristicsEEEE" },
  }
}
```

You can find examples for the interceptor generation in `generator_data/interceptor_data/`.
The following invocation of the interceptor generator emits Frida code that
1. hooks all specified functions (`onEnter` and `onLeave`)
2. calls the `dump()` function (generated by the dumper generator).

```
python -m generator.geninterceptor ./generator_data/interceptor_data/keystore_3.0.json
```

Excerpt from the generated code:
```
var fptr_generateKey = Module.getExportByName(module_name, '_ZN7android8hardware9keymaster4V3_019BpHwKeymasterDevice11generateKeyERKNS0_8hidl_vecINS2_12KeyParameterEEENSt3__18functionIFvNS2_9ErrorCodeERKNS4_IhEERKNS2_18KeyCharacteristicsEEEE');

Interceptor.attach(fptr_generateKey, {
    onEnter: function(args) {
        console.log("onEnter: generateKey()");
        this.args = new Array();
        send({
            'type': 'init_dump',
            'func': 'generateKey',
            'dump_id': DUMP_ID
        });
        dump("generateKey", args, this.args, null);
    },
    onLeave: function(ret) {
        console.log("onLeave: generateKey()");
        dump("generateKey", this.args, null, ret);
        DUMP_ID += 1;
    }
});
```

### The Dumper

The dumper generator is the more complex part of this project.
It is invoked like this:
```
python -m generator.gendumper <struct_name> <header_file> [<clang_options>]
```

E.g.:
```
LD_LIBRARY_PATH=. python -m generator.gendumper "KeymasterDevice" ./generator_data/aosp/KeymasterDevice.hpp -Wall -I./generator_data/aosp/libhardware/include/ -I./generator_data/aosp/core/libcutils/include/ -I./generator_data/aosp/core/libsystem/include/ -I/usr/lib/llvm-6.0/lib/clang/6.0.0/include/ -I./generator_data/aosp/ -I./generator_data/aosp/libhidl/base/include/ -I/usr/include/c++/6/ -I/usr/include/x86_64-linux-gnu/c++/6/ -I./generator_data/aosp/core/libutils/include/ -I./generator_data/aosp/libfmq/base/
```

### HIDL

Starting with Android O (8), Google replaces `libhardware` HALs with HIDL HALs.
The interface is no longer described using C headers located in `aosp/libhardware/` (e.g., `aosp/libhardware/include/hardware/keymaster2.h`), but by C++ or Java interfaces generated from so-called `.hal` files.

These header files can either be found *somewhere* in the AOSP or generated.

#### HIDL Headers in the AOSP

We found that some branches/commits within the AOSP contain the C++ header files.
The repo for the interface files is [https://android.googlesource.com/platform/hardware/interfaces](https://android.googlesource.com/platform/hardware/interfaces).
Commit `39d5d150d9ebbc71a6cdc8a06f8c8e646806bf04` contains many pre-generated header files.

#### Generating HIDL Headers

To generate header files ourselves, we need `hidl-gen` (available via AOSP).
```
$ . buid/envsetup.sh
$ lunch # choose target (bullhead?)
```

You can try to go to `hardware/interfaces/keymaster` and hit `mm` to build the module without its dependencies.

A more manual approach is the following.
For the keymaster we need (executed in aosp root folder):
```bash
$ hidl-gen -o out_dir -L c++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.keymaster@3.0
$ hidl-gen -o out_dir -L c++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hidl.base@1.0
$ hidl-gen -o out_dir -L c++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hidl.manager@1.0
```
It might be necessary to remove some comments from the `.hal` files and patch hash values in `hardware/interfaces/current.txt`, if `hidl-gen` fails.


### gendumper

*Important*: Change the suffix of the target header file to `.hpp`.
Otherwise clang will try to parse the header as c file instead of a c++ file.

Provide `libclang-<version>.so` in your `$LD_LIBRARY_PATH`.
With the correct include paths for clang we can then call `gen_dumper.py` (add `-v` for debug output):
```bash
$ ./gen_dumper.py "struct KeymasterDevice" path/to/out_dir/KeymasterDevice.hpp -Wall -I/usr/lib/llvm-10/lib/clang/10.0.0/include/ -I/usr/include/c++/9/ -I/usr/include/x86_64-linux-gnu/c++/9/ -I./aosp/core/libutils/include/ -I./aosp/libhardware/include/ -I./aosp/libfmq/base/ -I./aosp/core/libcutils/include/ -I./aosp/core/libsystem/include/ -I./aosp/libhidl/base/include/ -I./hidl_header/
```

## Misc

Get HAL headers and includes:
```
$ mkdir aosp; cd aosp
$ git clone https://android.googlesource.com/platform/hardware/libhardware
$ git clone https://android.googlesource.com/platform/system/core
$ git clone https://android.googlesource.com/platform/hardware/interfaces
$ git clone https://android.googlesource.com/platform/system/libhidl
$ git clone https://android.googlesource.com/platform/system/libfmq
```

We just took the master branchs' heads.
`68222be6674ffcf23f6eae56f1220fb93a366618` for `libhardware` and
`bc6372103ae969f70b8e6a293280145c8a467abc` for `core` at this time.

Have `libclang-7.so` in your library path. E.g.,
`ln -s /usr/lib/x86_64-linux-gnu/libclang-7.so.1 libclang-7.so`
to have it in `invoke.sh`'s path.

Check if paths in `invoke.sh` match.
Check that `/usr/lib/llvm-6.0/lib/clang/6.0.0/include/` (or similar) exist for you.

Giving `pyclang` files with `hpp` extensions (CPP header files) just works.
We just symlink all relevant headers like this:

```
ln -s ./aosp/libhardware/include/hardware/keymaster1.h ./km.hpp 
```

### Forward adb port

```
ssh -L 5037:localhost:5037 <remote>
```

## Testing

We have a bunch of testcases for regression tests.

```
$ . .venv/bin/activate # spawn your venv
$ cd generator/tests/data
$ make # will generate binaries/json files for tests
$ cd -
$ make test # execute tests
```

## Android VTS

Android provides a test suite for vendors (VTS). These tests can be used to record
seeds.
On Android/OPTEE, you can use `--gtest_list_tests` to list all tests and `--gtest_filter` to execute individual test cases.
```
/data/local/tmp/VtsHalKeymasterV3_0TargetTest --gtest_list_tests
/data/local/tmp/VtsHalKeymasterV3_0TargetTest --gtest_filter=NewKeyGenerationTest.Rsa
```
